{
  "data_structures": {
    "vertex": {
      "properties": [
        "x",
        "y",
        "color",
        "id",
        "selected"
      ], 
      "example": {
        "x": 100,
        "y": 150,
        "color": [
          1.0,
          0.0,
          0.0
        ],
        "id": 0,
        "selected": false
      }
    },
    "edge": {
      "properties": [
        "vertex1_id",
        "vertex2_id",
        "active"
      ],
      "example": {
        "vertex1_id": 0,
        "vertex2_id": 1,
        "active": true
      }
    },
    "triangle": {
      "properties": [
        "vertex1_id",
        "vertex2_id",
        "vertex3_id",
        "density",
        "color"
      ],
      "example": {
        "vertex1_id": 0,
        "vertex2_id": 1,
        "vertex3_id": 2,
        "density": 3,
        "color": [
          0.0,
          1.0,
          0.0
        ]
      }
    },
    "dot": {
      "properties": [
        "x",
        "y",
        "triangle_id",
        "moving"
      ],
      "example": {
        "x": 125,
        "y": 175,
        "triangle_id": 0,
        "moving": false
      }
    }
  },
  "color_scheme": {
    "under_populated": {
      "color": [
        0.0,
        0.0,
        1.0
      ],
      "description": "Blue - Less than target density"
    },
    "optimal_density": {
      "color": [
        0.0,
        1.0,
        0.0
      ],
      "description": "Green - Optimal density (e.g., 4 people)"
    },
    "over_populated": {
      "color": [
        1.0,
        0.0,
        0.0
      ],
      "description": "Red - More than target density"
    }
  },
  "key_algorithms": {
    "mouse_picking": {
      "description": "Convert mouse coordinates to world coordinates and identify clicked objects",
      "steps": [
        "Convert screen coordinates to normalized device coordinates",
        "Use inverse projection matrix to get world coordinates",
        "Perform ray-triangle intersection or use color picking"
      ]
    },
    "edge_management": {
      "description": "Add and remove edges while maintaining valid triangulation",
      "steps": [
        "Validate edge doesn't create self-intersections",
        "Update triangle list when edges are added/removed",
        "Maintain connectivity information"
      ]
    },
    "density_calculation": {
      "description": "Count dots in each triangle and assign colors",
      "steps": [
        "For each triangle, count dots inside using point-in-triangle test",
        "Compare count to target density",
        "Assign appropriate color (red/green/blue)"
      ]
    },
    "triangle_coloring": {
      "description": "Update triangle colors based on population density",
      "formula": "if dot_count < target_density: blue, elif dot_count == target_density: green, else: red"
    }
  },
  "implementation_phases": {
    "phase_1": {
      "name": "Basic Setup",
      "tasks": [
        "Initialize WebGL context and shaders",
        "Create rectangle boundary",
        "Implement basic vertex rendering"
      ]
    },
    "phase_2": {
      "name": "Triangle Management",
      "tasks": [
        "Implement triangle data structure",
        "Add edge creation/deletion functionality",
        "Implement triangle formation from edges"
      ]
    },
    "phase_3": {
      "name": "Interactive Features",
      "tasks": [
        "Add mouse picking for vertex selection",
        "Implement edge addition/deletion via mouse clicks",
        "Add keyboard shortcuts for different modes"
      ]
    },
    "phase_4": {
      "name": "Crowd Simulation",
      "tasks": [
        "Add dots (people) to triangles",
        "Implement density-based coloring",
        "Add dot movement between triangles"
      ]
    }
  }
}